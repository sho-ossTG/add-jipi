---
phase: 04-observability-and-diagnostics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - observability/context.js
  - observability/logger.js
  - observability/events.js
  - serverless.js
  - tests/contract-observability.test.js
  - package.json
autonomous: true
requirements:
  - OBSV-01
  - OBSV-02
must_haves:
  truths:
    - "Every request path emits a correlation ID that operators can follow across request, policy, dependency, and completion events."
    - "Failure telemetry uses deterministic structured fields that classify source as broker, redis, validation, or policy."
    - "Correlated telemetry remains structured JSON and does not rely on ad-hoc free-form message parsing."
  artifacts:
    - path: observability/context.js
      provides: "AsyncLocalStorage request context with correlation ID extract-or-generate behavior"
    - path: observability/events.js
      provides: "Canonical telemetry taxonomy and failure-source classification helpers"
    - path: observability/logger.js
      provides: "Structured logger with safe redaction and correlation bindings"
    - path: serverless.js
      provides: "Request lifecycle instrumentation that emits correlated request/policy/dependency/completion events"
    - path: tests/contract-observability.test.js
      provides: "Contract checks for correlation propagation and taxonomy source classification"
  key_links:
    - from: serverless.js
      to: observability/context.js
      via: "request handler wrapped in request context before route dispatch"
      pattern: "withRequestContext|x-correlation-id|X-Correlation-Id"
    - from: serverless.js
      to: observability/events.js
      via: "policy/dependency/error branches emit canonical structured events"
      pattern: "emitEvent|category|source|cause"
    - from: tests/contract-observability.test.js
      to: serverless.js
      via: "handler-boundary assertions on emitted JSON telemetry fields"
      pattern: "correlationId|policy|dependency|validation|broker|redis"
---

<objective>
Implement a request-scoped observability foundation with correlation IDs and canonical failure taxonomy.

Purpose: Let operators trace degraded and failed requests end-to-end and classify root source reliably without log-shape drift.
Output: Reusable observability modules integrated into the server handler, plus contract tests for correlation and taxonomy guarantees.
</objective>

<execution_context>
@C:/Users/enggy/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/enggy/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-observability-and-diagnostics/04-RESEARCH.md
@.planning/phases/03-stream-reliability-controls/03-02-SUMMARY.md
@serverless.js
@tests/contract-stream-reliability.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create request context and structured telemetry primitives</name>
  <files>observability/context.js, observability/logger.js, observability/events.js</files>
  <action>Create a dedicated observability module set using CommonJS: `observability/context.js` for AsyncLocalStorage correlation context (`x-correlation-id` passthrough or `crypto.randomUUID()` generation), `observability/logger.js` for pino JSON logger with redaction of sensitive headers/tokens, and `observability/events.js` for a single canonical taxonomy (`category`, `source`, `cause`, `event`, `correlationId`). Include strict failure-source mapping helpers that classify broker, redis, validation, and policy failures consistently. Do not add ad-hoc event names outside this module.</action>
  <verify>Run `node -e "require('./observability/context'); require('./observability/logger'); require('./observability/events');"` and confirm no module load errors.</verify>
  <done>Observability primitives exist as reusable modules and provide one canonical correlation + taxonomy contract for all request paths.</done>
</task>

<task type="auto">
  <name>Task 2: Instrument server request lifecycle with correlated taxonomy events</name>
  <files>serverless.js</files>
  <action>Integrate observability primitives into `serverless.js` so every request runs inside request context and receives `X-Correlation-Id` response header. Emit structured lifecycle events at minimum for request start/end, policy decisions, stream dependency attempts/failures, and degraded exits. Ensure emitted events always carry `correlationId` and canonical taxonomy fields; route existing reliability failure causes through the new classifier instead of free-form error strings. Keep client-facing payloads unchanged except for correlation header and preserve operator auth/CORS behavior from Phase 2.</action>
  <verify>Run `npm run test:contract:reliability && npm run test:contract:stream && npm run test:contract:security && npm run test:contract:cors`.</verify>
  <done>Operators can trace each failing/degraded request by one correlation ID across request, policy, and dependency event chain without regressing existing reliability/security behavior.</done>
</task>

<task type="auto">
  <name>Task 3: Add observability contract tests for correlation and source taxonomy</name>
  <files>tests/contract-observability.test.js, package.json</files>
  <action>Create `tests/contract-observability.test.js` in existing Node test style with handler-boundary doubles that capture emitted telemetry. Add assertions that: (1) all lifecycle events for one request share the same non-empty correlation ID, (2) broker/redis/validation/policy failures map to expected `source` category fields, and (3) unknown free-form sources are rejected or normalized to canonical values. Update `package.json` to add `pino` dependency and `test:contract:observability` script while keeping existing scripts intact.</action>
  <verify>Run `npm run test:contract:observability && npm run test:contract:reliability`.</verify>
  <done>Correlation propagation and structured source taxonomy are regression-locked by executable contract tests.</done>
</task>

</tasks>

<verification>
Run `npm run test:contract:observability && npm run test:contract:reliability && npm run test:contract:stream && npm run test:contract:security && npm run test:contract:cors`.
</verification>

<success_criteria>
1. Request, policy, dependency, and completion telemetry for one request share a single correlation ID.
2. Failure source taxonomy is deterministic across broker, redis, validation, and policy failure classes.
3. Existing stream/security contract behavior remains green after instrumentation.
</success_criteria>

<output>
After completion, create `.planning/phases/04-observability-and-diagnostics/04-01-SUMMARY.md`
</output>
