---
phase: 03-stream-reliability-controls
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - serverless.js
  - tests/contract-stream-reliability.test.js
  - package.json
autonomous: true
requirements:
  - RELY-01
  - RELY-03
must_haves:
  truths:
    - "Capacity and policy denials always return protocol-safe empty `streams` with actionable busy/policy messaging."
    - "Dependency failures (broker/Redis timeout or unavailable) always return a deterministic fallback playable stream response."
    - "Rapid episode switching for the same client is deterministic, with latest request winning."
    - "The same failure cause always maps to the same response pattern across repeated requests."
  artifacts:
    - path: serverless.js
      provides: "Central cause classifier and deterministic degraded response mapping integrated into stream handler exits"
    - path: tests/contract-stream-reliability.test.js
      provides: "Regression coverage for cause-to-response determinism, fallback behavior, and latest-request-wins semantics"
    - path: package.json
      provides: "Reliability contract script coverage kept in main test matrix"
  key_links:
    - from: serverless.js
      to: "stream response payload"
      via: "cause classification -> degraded response map"
      pattern: "cause|degraded|streams: \[\]|sendErrorStream"
    - from: serverless.js
      to: "in-flight request tracking"
      via: "latest episode token/version check per client"
      pattern: "latest.*client|episode|inFlight"
    - from: tests/contract-stream-reliability.test.js
      to: "serverless handler"
      via: "HTTP boundary assertions for response shape by cause"
      pattern: "streams|busy|retry|fallback"
---

<objective>
Enforce deterministic degraded response policy so every reliability failure path remains protocol-safe and predictable to clients.

Purpose: Guarantee stable user-facing behavior when capacity or dependencies degrade, preventing ambiguous or inconsistent stream outcomes.
Output: Cause-mapped stream responses plus reliability response-determinism tests.
</objective>

<execution_context>
@C:/Users/enggy/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/enggy/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stream-reliability-controls/03-CONTEXT.md
@.planning/phases/03-stream-reliability-controls/03-RESEARCH.md
@.planning/phases/03-stream-reliability-controls/03-01-SUMMARY.md
@serverless.js
@tests/contract-stream.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Centralize deterministic cause-to-response degraded mapping</name>
  <files>serverless.js</files>
  <action>Create one explicit mapping table from reliability causes to final stream outputs and message text, then route all stream blocked/degraded/error exits through it. Enforce locked hybrid behavior: capacity/policy causes return `{ streams: [] }` with actionable busy/policy guidance; dependency-failure causes return fallback playable stream entries with actionable retry-soon messaging. Keep response shape consistent and deterministic for repeated same-cause outcomes, and avoid leaking internal retry/merge state in client text.</action>
  <verify>Run `node --test tests/contract-stream-reliability.test.js` and assert each cause category always yields the same response shape and message class.</verify>
  <done>All stream-path degraded outcomes use a single deterministic mapping and remain protocol-safe under failure.</done>
</task>

<task type="auto">
  <name>Task 2: Enforce latest-request-wins behavior for rapid episode switching</name>
  <files>serverless.js</files>
  <action>Extend in-flight request orchestration so same-client+same-episode requests continue to join one in-flight intent, but rapid same-client episode changes invalidate older intent and return the latest request result deterministically. Ensure stale in-flight completions cannot overwrite latest selection response state, and cleanup in-flight tracking in `finally` paths to avoid memory leaks.</action>
  <verify>Run `node --test tests/contract-stream-reliability.test.js` and confirm overlapping same-client episode A->B requests resolve with B as authoritative output while duplicate A requests still coalesce.</verify>
  <done>Duplicate bursts are deduped, episode switches are deterministic with latest-wins semantics, and in-flight state is safely cleaned up.</done>
</task>

<task type="auto">
  <name>Task 3: Expand reliability contracts for degraded determinism and latest-wins flow</name>
  <files>tests/contract-stream-reliability.test.js, package.json</files>
  <action>Extend `tests/contract-stream-reliability.test.js` with deterministic response mapping coverage for capacity/policy, dependency timeout, and dependency unavailable causes, plus latest-request-wins assertions for rapid episode switching. Keep script wiring through `test:contract:reliability` and preserve compatibility with existing stream/security/cors/manifest test suites.</action>
  <verify>Run `npm run test:contract:reliability && npm run test:contract:stream && npm run test:contract:security && npm run test:contract:cors && npm run test:contract:manifest-catalog`.</verify>
  <done>Client-visible degraded behavior and latest-wins semantics are regression-locked with deterministic handler-level tests.</done>
</task>

</tasks>

<verification>
Run `npm run test:contract:reliability && npm run test:contract:stream && npm run test:contract:security && npm run test:contract:cors && npm run test:contract:manifest-catalog`.
</verification>

<success_criteria>
1. Capacity/policy causes always produce empty streams with actionable busy/policy messaging.
2. Broker/Redis dependency failures always produce deterministic fallback playable stream behavior.
3. Rapid same-client episode switching always yields latest-request output, not stale earlier results.
</success_criteria>

<output>
After completion, create `.planning/phases/03-stream-reliability-controls/03-02-SUMMARY.md`
</output>
