---
phase: 03-stream-reliability-controls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - serverless.js
  - addon.js
  - tests/contract-stream-reliability.test.js
  - package.json
autonomous: true
requirements:
  - RELY-01
  - RELY-02
must_haves:
  truths:
    - "Concurrent stream requests apply one atomic capacity/session decision with deterministic admit vs block outcomes."
    - "When capacity is full, oldest idle session rotation and reconnect grace are enforced consistently."
    - "Stream-path dependency calls complete within a bounded timeout budget with at most one transient retry."
    - "Burst-identical requests from the same client and episode are coalesced into one active intent path."
  artifacts:
    - path: serverless.js
      provides: "Atomic Redis gate flow (cleanup, fair rotation, grace handling, heartbeat) and in-flight dedupe orchestration"
    - path: addon.js
      provides: "Bounded broker resolve execution using timeout + single jittered retry"
    - path: tests/contract-stream-reliability.test.js
      provides: "Regression coverage for atomic admission/rotation outcomes and bounded dependency timing"
    - path: package.json
      provides: "Executable reliability contract test script"
  key_links:
    - from: serverless.js
      to: "Upstash Redis transaction endpoint"
      via: "atomic gate helper used by applyRequestControls"
      pattern: "multi-exec|EVAL|applyRequestControls"
    - from: addon.js
      to: "broker resolve endpoint"
      via: "timeout-bounded fetch wrapper with one retry"
      pattern: "AbortSignal\.timeout|retry|callBrokerResolve"
    - from: serverless.js
      to: "stream route handler"
      via: "in-flight key join for same client+episode"
      pattern: "inFlight|client.*episode|handleStreamRequest"
---

<objective>
Build deterministic concurrency and dependency-control primitives so stream requests stay bounded and consistent under load.

Purpose: Eliminate race windows and hung dependency calls that break reliability under concurrent stream demand.
Output: Atomic Redis gate behavior plus bounded timeout/retry execution with contract tests.
</objective>

<execution_context>
@C:/Users/enggy/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/enggy/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stream-reliability-controls/03-CONTEXT.md
@.planning/phases/03-stream-reliability-controls/03-RESEARCH.md
@.planning/phases/02-security-boundary-hardening/02-02-SUMMARY.md
@serverless.js
@addon.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace non-atomic session gating with atomic fair-rotation gate logic</name>
  <files>serverless.js</files>
  <action>Refactor stream admission controls to execute as one atomic Redis gate operation (`/multi-exec` or `EVAL`) instead of separate `/pipeline` checks. In that atomic step: prune inactive sessions, preserve reconnects within a short grace window, coalesce same-client intent, and apply fair rotation by replacing the oldest idle session when capacity is full. Keep blocked policy/capacity outcomes deterministic and non-error at stream boundary, and avoid introducing non-stream hard failures for admission denials.</action>
  <verify>Run `node --test tests/contract-stream-reliability.test.js` and confirm concurrent admission tests always converge to deterministic admitted/blocked outcomes without over-capacity drift.</verify>
  <done>Concurrency gating is atomic and deterministic under parallel requests, with fair rotation and reconnect grace behavior aligned to locked decisions.</done>
</task>

<task type="auto">
  <name>Task 2: Add bounded dependency executor with one jittered transient retry</name>
  <files>addon.js, serverless.js</files>
  <action>Implement a shared bounded dependency execution pattern for broker and Redis stream-path calls using `AbortSignal.timeout(...)`, a moderate per-attempt deadline, and exactly one quick jittered retry only for transient classes (`408/429/5xx`, timeout/reset). Enforce total operation budget so retry cannot create hung or unbounded latency tails. Keep client output focused on final deterministic outcome and do not expose internal retry stage details.</action>
  <verify>Run `node --test tests/contract-stream-reliability.test.js` and verify timeout cases fail within budget while transient failures attempt one retry and then return final bounded result.</verify>
  <done>Dependency calls never hang indefinitely, retry behavior is bounded and transient-only, and total stream-path latency remains capped.</done>
</task>

<task type="auto">
  <name>Task 3: Add reliability contract tests and test script wiring</name>
  <files>tests/contract-stream-reliability.test.js, package.json</files>
  <action>Create `tests/contract-stream-reliability.test.js` using existing handler-boundary Node test style with fetch/Redis doubles to cover: atomic gate determinism under concurrent requests, fair idle rotation behavior, reconnect grace continuity, duplicate same-client+episode coalescing, and bounded timeout+single-retry execution. Add `test:contract:reliability` script in `package.json` and keep existing contract suites intact.</action>
  <verify>Run `npm run test:contract:reliability && npm run test:contract:stream && npm run test:contract:security && npm run test:contract:cors && npm run test:contract:manifest-catalog`.</verify>
  <done>Reliability controls are locked by executable regression tests and all existing contract suites remain green.</done>
</task>

</tasks>

<verification>
Run `npm run test:contract:reliability && npm run test:contract:stream && npm run test:contract:security && npm run test:contract:cors && npm run test:contract:manifest-catalog`.
</verification>

<success_criteria>
1. Concurrent stream admissions no longer race into inconsistent capacity outcomes.
2. Stream-path dependency operations always terminate within defined timeout/retry bounds.
3. Duplicate burst requests for the same client and episode share a single active intent path.
</success_criteria>

<output>
After completion, create `.planning/phases/03-stream-reliability-controls/03-01-SUMMARY.md`
</output>
