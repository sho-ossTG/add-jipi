---
phase: 01-contract-compatibility-baseline
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - serverless.js
  - addon.js
  - tests/contract-stream.test.js
  - package.json
autonomous: false
requirements:
  - CONT-03
must_haves:
  truths:
    - User requesting a supported episode receives a protocol-valid stream payload.
    - Stream failure and control-block paths still return protocol-safe stream responses.
    - Non-stream blocked routes keep baseline JSON error/status behavior.
  artifacts:
    - path: serverless.js
      provides: Stream interception, fallback eligibility, and policy-gated response behavior.
      contains: "handleStreamRequest"
    - path: addon.js
      provides: Stream handler contract for supported series IDs.
      contains: "defineStreamHandler"
    - path: tests/contract-stream.test.js
      provides: Automated stream contract and fallback assertions.
      contains: "streams"
    - path: package.json
      provides: Runnable stream contract test command.
      contains: "test:contract:stream"
  key_links:
    - from: serverless.js
      to: addon.js
      via: "addonInterface.resolveEpisode(episodeId)"
      pattern: "resolveEpisode\\(episodeId\\)"
    - from: serverless.js
      to: stream response
      via: "sendErrorStream -> sendJson({ streams: [...] })"
      pattern: "sendErrorStream"
---

<objective>
Guarantee supported-episode stream responses stay protocol-valid across success and failure paths while preserving locked baseline fallback semantics.

Purpose: Complete Phase 1 compatibility by hardening stream-path contract behavior under real policy and dependency outcomes.
Output: Stream contract-safe handling plus executable stream compatibility tests and client verification.
</objective>

<execution_context>
@C:/Users/enggy/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/enggy/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-contract-compatibility-baseline/01-CONTEXT.md
@.planning/phases/01-contract-compatibility-baseline/01-RESEARCH.md
@.planning/phases/01-contract-compatibility-baseline/01-01-SUMMARY.md
@serverless.js
@addon.js
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Harden stream contract behavior without changing baseline policy</name>
  <files>serverless.js, addon.js</files>
  <action>Ensure `/stream/series/:id.json` handling always returns a Stremio-compatible `{ streams: [...] }` or `{ streams: [] }` payload for supported/unsupported and failure branches, while keeping current locked behavior: existing fallback eligibility categories, no new retry loop, mixed non-stream JSON status behavior, and no public correlation identifiers. If improvements are needed, keep them non-breaking and constrained to contract safety plus actionable mid-level error wording.</action>
  <verify>Run `node -e "const fs=require('fs'); const s=fs.readFileSync('serverless.js','utf8'); if(!/sendErrorStream/.test(s)||!/streams/.test(s)) throw new Error('stream fallback contract missing'); console.log('stream-contract-guards-present');"`</verify>
  <done>All stream-path outcomes for supported episodes are protocol-valid and baseline fallback semantics remain intact.</done>
</task>

<task type="auto">
  <name>Task 2: Add automated stream compatibility tests</name>
  <files>tests/contract-stream.test.js, package.json</files>
  <action>Create Node built-in tests covering stream success and degraded paths: supported episode request returns `200` with `streams` array and HTTPS URL/fallback stream object; control-blocked stream route still returns contract-valid stream payload; unsupported stream IDs remain protocol-safe (empty streams via addon route or equivalent baseline path). Add npm script `test:contract:stream` and keep tests deterministic by mocking broker/Redis boundaries as needed.</action>
  <verify>Run `npm run test:contract:stream` and confirm all tests pass.</verify>
  <done>Automated checks catch regressions where stream routes emit malformed payloads or break baseline fallback behavior.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify install and playback flow in Stremio client</name>
  <action>Run a single end-to-end human verification after automated checks finish to confirm real client compatibility for install, catalog browse, and supported episode playback/degraded behavior.</action>
  <verify>1) Start locally with required env vars and run `npm start`. 2) In Stremio, install the addon using `http://127.0.0.1:PORT/manifest.json` (or deployed HTTPS manifest URL for remote). 3) Open addon catalog and confirm One Piece entry renders. 4) Open a supported episode and confirm a stream appears and enters playback flow. 5) Trigger a known degraded path (for example temporary broker failure) and confirm response remains protocol-safe with actionable message.</verify>
  <done>Human verification confirms install, catalog, and stream playback flow succeeds in client context, or returns actionable defect details for follow-up.</done>
  <resume-signal>Type "approved" when verified, or provide exact failing step/output.</resume-signal>
</task>

</tasks>

<verification>
Run `npm run test:contract:manifest-catalog && npm run test:contract:stream`, then complete the Stremio install/browse/playback manual verification checkpoint.</verification>

<success_criteria>
1. Supported episode stream requests return protocol-valid `streams` payloads.
2. Stream failure/control-block paths preserve baseline fallback eligibility and remain contract-safe.
3. Manual Stremio install, catalog browse, and episode playback flow is verified end-to-end.</success_criteria>

<output>
After completion, create `.planning/phases/01-contract-compatibility-baseline/01-02-SUMMARY.md`
</output>
